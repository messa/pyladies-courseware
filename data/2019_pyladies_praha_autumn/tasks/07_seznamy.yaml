tasks:

- section:
    markdown: |
      Čeká tě procvičování práce se seznamy.
      Některé z projektů – a zvlášť ten poslední – potřebují trochu přemýšlení;
      nebudeš-li vědět jak dál, zeptej se na internetu nebo na sraze ostatních
      a řešte společně!

- id: handout6_03
  markdown: |
    a) Udělej si seznam domácích zvířat. Budeš ho potřebovat v dalších úlohách.
    Domácí zvířata známe tato: `"pes", "kočka", "králík", "had"`.
    
    b) Napiš funkci, která přebere seznam zvířat a slovo a zjistí, jestli je toto slovo v seznamu.

    _„Zjistí“ znamená, že funkce vrátí `True` nebo `False`._
    _Aby ti fungovaly testy, pojmenuj prosím funkci je_v_seznamu._
    
  mandatory: true
  
  tests: |
    def test_zadany_seznam_true():
        assert je_v_seznamu(["pes", "kočka", "králík", "had"], "králík") == True, "Zdá se, že slovo v seznamu je, ale tvůj program tvrdí, že ne. Zkus to znovu."

    def test_zadany_seznam_false():
        assert je_v_seznamu(["pes", "kočka", "králík", "had"], "hroch") == False, "Zdá se, že slovo v seznamu není, ale tvůj program tvrdí, že je. Zkus to znovu."

    def test_jiny_seznam_true():
        assert je_v_seznamu(["užovka", "koroptev", "mravenec", "vlk", "plch"], "užovka") == True, "Při zadání jiného seznamu než [\"pes\", \"kočka\", \"králík\", \"had\"] nastal problém. Zkus zařídit, aby funkce dokázala pracovat i s jinými seznamy."

    def test_jiny_seznam_false():
        assert je_v_seznamu(["užovka", "koroptev", "mravenec", "vlk", "plch"], "hroch") == False, "Při zadání jiného seznamu než [\"pes\", \"kočka\", \"králík\", \"had\"] nastal problém.Zkus zařídit, aby funkce dokázala pracovat i s jinými seznamy."


- id: handout6_04
  markdown: |
    Napiš funkci, která dostane dva seznamy jmen zvířat a vrátí tři seznamy:

    - zvířata, která jsou v obou seznamech současně (průnik množin: první ∩ druhá),
    - zvířata, která jsou jen v prvním seznamu (rozdíl množin: první - druhá),
    - zvířata, která jsou jen ve druhém seznamu (rozdíl množin: druhá - první).
    
    _Aby ti fungovaly testy, pojmenuj prosím funkci tri_seznamy a seznamy vracej ve výše uvedeném pořadí._

  mandatory: true
  
  tests: |
    def test_zadany_seznam_tri():
        assert tri_seznamy(["pes", "kočka", "králík", "had"],["kočka","lev", "králík", "vorvaň"]) == (["kočka", "králík"],["pes","had"],["lev","vorvaň"]), "Zkontroluj jestli funkce dělá, co má, a formát, ve kterém vrací výsledek - měla by to být n-tice sestávající ze tří seznamů, dál viz zadání."
    
    def test_jiny_seznam_tri():
        assert tri_seznamy(["užovka", "koroptev", "mravenec", "vlk", "plch"],["kočka","lev", "koroptev", "mravenec", "vlk", "králík", "vorvaň"]) == (['koroptev', 'mravenec', 'vlk'], ['užovka', 'plch'], ['kočka', 'lev', 'králík', 'vorvaň']), "Pokud ti předchozí test prošel, a tento ne, zkus upravit svou funkci tak, aby fungovala i pro jiné seznamy, než seznam z úkolu 0."


- id: handout6_01
  markdown: |
    Napiš funkci, která vrací jména domácích zvířat (ze seznamu zadaného argumentem), která jsou kratší než 5 písmen.
    _Aby ti fungovaly připravené testy, pojmenuj funkci kratka._
    
  tests: |
    def test_zadany_seznam_kratka():
        assert kratka(["pes", "kočka", "králík", "had"]) == ["pes", "had"], "Zkontroluj jestli funkce dělá, co má, a formát, ve kterém vrací výsledek - test počítá s tím, že tvoje funkce vrací seznam."

    def test_jiny_seznam_kratka():
        assert kratka(["užovka", "koroptev", "mravenec", "vlk", "plch", "bů"]) == ["vlk", "plch", "bů"], "Pokud ti předchozí test prošel, a tento ne, zkus upravit svou funkci tak, aby fungovala i pro jiné seznamy, než seznam z úkolu 0."


- id: handout6_02
  markdown: |
    Napiš funkci, která vrací jména domácích zvířat (ze seznamu zadaného argumentem), která začínají na `k`.
    _Aby ti fungovaly připravené testy, pojmenuj funkci zacina_k._
    
  tests: |
    def test_zadany_seznam_k():
        assert  zacina_k(["pes", "kočka", "králík", "had"]) == ["kočka", "králík"], "Zkontroluj jestli funkce dělá, co má, a formát, ve kterém vrací výsledek - test počítá s tím, že tvoje funkce vrací seznam."
   
    def test_jiny_seznam_k():
        assert  zacina_k(["užovka", "koroptev", "mravenec", "vlk", "plch"]) == ["koroptev"], "Pokud ti předchozí test prošel, a tento ne, zkus upravit svou funkci tak, aby fungovala i pro jiné seznamy, než seznam z úkolu 0."

- id: handout6_05
  markdown: |
    Napiš program, který seřadí seznam domácích zvířat podle abecedy.
    _Aby ti fungovaly připravené testy, pojmenuj funkci abecedne._
    
  tests: |
    def test_zadany_seznam_abecedne():
        assert abecedne(["pes", "kočka", "králík", "had"]) == ["had", "kočka", "králík", "pes"], "Zkontroluj jestli funkce dělá, co má, a formát, ve kterém vrací výsledek - test počítá s tím, že tvoje funkce vrací seznam."
    
    def test_jiny_seznam_abecedne():
        assert abecedne(["užovka", "koroptev", "mravenec", "vlk", "plch"]) == ["koroptev", "mravenec", "plch", "užovka", "vlk"], "Pokud ti předchozí test prošel, a tento ne, zkus upravit svou funkci tak, aby fungovala i pro jiné seznamy, než seznam z úkolu 0."


- id: handout6_06
  markdown: |
    Had byl pyšný na to, že je v abecedě první.
    Dokud nepřiletěla `"andulka"`.

    Abys hada uklidnila, vytvoř funkci, která zvířata seřadí podle abecedy,
    ale bude ignorovat první písmeno t.j. vrátí:

    <pre>
    "h<span style='color: pink'>ad</span>",
    "p<span style='color: pink'>es</span>",
    "a<span style='color: pink'>ndulka</span>",
    "k<span style='color: pink'>očka</span>",
    "k<span style='color: pink'>rálík</span>".
    </pre>

    Postup:

    - Máš seznam _hodnot_, které chceš seřadit podle nějakého
        _klíče_. Klíč se dá z každé hodnoty vypočítat.
    - Vytvoř seznam dvojic `(klíč, hodnota)`.
    - Seřaď tento seznam dvojic – dvojice se řadí nejdřív podle
        prvního prvku, pak druhého atd.
    - Nakonec vytvoř ze seznamu dvojic opět jen seznam hodnot.

    Proč má zrovna had takovéhle výsadní postavení, zjistíš později.
    _Aby ti fungovaly připravené testy, pojmenuj funkci abecedne_2 a zařiď, aby vracela seznam._
    
 tests: |
    def test_zadany_seznam_abecedne_2():
        assert abecedne_2(["pes", "kočka", "králík", "had", "andulka"]) == ["had", "pes", "andulka", "kočka", "králík"], "Zkontroluj jestli funkce dělá, co má, a formát, ve kterém vrací výsledek - test počítá s tím, že tvoje funkce vrací seznam."
   
   def test_jiny_seznam_abecedne_2():
        assert abecedne_2(["aba", "la", "ad", "ea"]) == ["ea", "la", "aba", "ad"], "Pokud ti předchozí test prošel, a tento ne, zkus upravit svou funkci tak, aby fungovala i pro jiné seznamy, než seznam z úkolu 0."

- section:
    markdown: |
      Jedna klasická programovací úloha, která nejspíš pořádně potrápí
      tvé logické myšlení. Je nepovinná, nemáš-li na ni aspoň pár hodin,
      tak ji přeskoč.

- id: handout6_09
  markdown: |
    Napiš funkci, která převede římské číslice na číslo (`int`).
    _Aby ti fungovaly připravené testy, pojmenuj funkci rimska_na_int._
    
  tests: |
    def test_rimska_na_int():
        assert rimska_na_int("V") == 5
        assert rimska_na_int("IX") == 9
        assert rimska_na_int("XIV") == 14
        #assert rimska_na_int("IIII") == 4           # mám jí tam nechat? Jsou o ní trochu spory, jestli je to přijatelný zápis.
        assert rimska_na_int("IV") == 4
        assert rimska_na_int("CMXCIX") == 999
        assert rimska_na_int("CDXLIV") == 444
        assert rimska_na_int("MDCLXVI") == 1666
        assert rimska_na_int("MCDLXXVI") == 1476


- section:
    markdown: |
        A nakonec projekt na přemýšlení.

- id: handout6_17
  markdown: |
    Může seznam obsahovat sám sebe? Zkus co nejjednodušeji udělat takový seznam, aby platilo:

        seznam[5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][0] == 5
        
  tests: |
    def test_seznam():
        assert seznam[5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][5][0] == 5
